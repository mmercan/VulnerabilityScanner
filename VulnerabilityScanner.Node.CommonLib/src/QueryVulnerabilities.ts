import request = require('request');
import { IPackage, IVulnerability, IProject, IProjectDic } from './models';
export default class QueryVulnerabilities {
  globalPackageList: any = {};

  public async QueryAllPackages(projects: IProjectDic) {
    await this.getVulnerabilityreports(projects);

    for (const prj in projects) {
      for (const pcks in projects[prj].results) {
        if (this.globalPackageList[pcks]) {
          projects[prj].results[pcks] = this.globalPackageList[pcks];
        }
      }
    }
  }

  public async getVulnerabilityreports(projects: IProjectDic) {
    const pageitem = 127;
    const allpages = [];
    const packagecoordinates = this.listAllPackages(projects);
    const totalpageNumber = Math.ceil(packagecoordinates.length / pageitem);

    for (let index = 0; index < totalpageNumber; index++) {
      const paged = this.paginate(packagecoordinates, pageitem, index);
      allpages.push(paged);

      try {
        await this.queryPackages(paged);
      } catch (error) {
        console.log(`catch: ${error}`);
      }
    }
    return allpages;
  }

  listAllPackages(projects: IProjectDic): any {
    const packagecoordinates: any = {};

    for (const prj in projects) {
      for (const pcks in projects[prj].results) {
        if (!packagecoordinates[pcks]) {
          packagecoordinates[pcks] = {};
        }
      }
    }

    const packageList = [];
    for (const key in packagecoordinates) {
      packageList.push(key);
    }
    return packageList;
  }

  paginate(array: any[], pageSize: number, pageNumber: number) {
    return array.slice(pageNumber * pageSize, (pageNumber + 1) * pageSize);
  }

  queryPackages(packagecoordinates: string[]) {
    return new Promise((resolve, reject) => {
      request.post(
        'https://ossindex.sonatype.org/api/v3/component-report',
        { json: { coordinates: packagecoordinates } },
        (error, res, body: IPackage[]) => {
          if (error) {
            console.error(error);
            reject(error);
            return;
          }
          console.log(`statusCode: ${res.statusCode}`);
          if (res.statusCode === 200) {
            body.forEach((pck) => {
              this.extractpackagedata(pck);
            });
            resolve(body);
          } else {
            reject(body);
          }
        },
      );
    });
  }

  extractpackagedata(pck: IPackage) {
    const item: any = {};
    item.coordinates = pck.coordinates;
    item.highestCvssScore = 0;
    if (pck.vulnerabilities.length > 0) {
      item.vulnerabilityText = 'There are  ' + pck.vulnerabilities.length + ' vulnerabilities';
      item.vulnerabilityCount = pck.vulnerabilities.length;
      item.vulnerabilities = pck.vulnerabilities;

      item.vulnerabilities.forEach((vulnerability: any) => {
        if (vulnerability.cvssScore) {
          if (vulnerability.cvssScore > item.highestCvssScore) {
            item.highestCvssScore = vulnerability.cvssScore;
          }

          if (vulnerability.cvssScore >= 0.1 && vulnerability.cvssScore <= 3.9) {
            vulnerability.severity = 'LOW';
            // if (failifseverityhigher == "LOW") {
            //     shouldTaskFails = true;
            //     vulnerability.TaskFailed = "Task Will Fail"
            // }
          }

          if (vulnerability.cvssScore >= 4.0 && vulnerability.cvssScore <= 6.9) {
            vulnerability.severity = 'MEDIUM';
            // severityForegroundColor = ConsoleColor.Yellow;
            // if (failifseverityhigher == "LOW" || failifseverityhigher == "MEDIUM") {
            //     shouldTaskFails = true;
            //     vulnerability.TaskFailed = "Task Will Fail"
            // }
          }

          if (vulnerability.cvssScore >= 7.0 && vulnerability.cvssScore <= 8.9) {
            vulnerability.severity = 'HIGH';
            // severityForegroundColor = ConsoleColor.Red;
            // if (failifseverityhigher == "LOW" || failifseverityhigher == "MEDIUM" ||
            //     failifseverityhigher == "HIGH") {
            //     shouldTaskFails = true;
            //     vulnerability.TaskFailed = "Task Will Fail"
            // }
          }

          if (vulnerability.cvssScore >= 9.0) {
            vulnerability.severity = 'CRITICAL';
            // severityForegroundColor = ConsoleColor.Red;
            // if (failifseverityhigher == "LOW" || failifseverityhigher == "MEDIUM" ||
            //     failifseverityhigher == "HIGH" || failifseverityhigher == "CRITICAL") {
            //     shouldTaskFails = true;
            //     vulnerability.TaskFailed = "Task Will Fail"
            // }
          }
        }
      });

      if (item.highestCvssScore === 0) {
        item.highestSeverity = 'NONE';
      }
      if (item.highestCvssScore >= 0.1 && item.highestCvssScore <= 3.9) {
        item.highestSeverity = 'LOW';
      } else if (item.highestCvssScore >= 4.0 && item.highestCvssScore <= 6.9) {
        item.highestSeverity = 'MEDIUM';
      } else if (item.highestCvssScore >= 7.0 && item.highestCvssScore <= 8.9) {
        item.highestSeverity = 'HIGH';
      } else if (item.highestCvssScore >= 9.0) {
        item.highestSeverity = 'CRITICAL';
      }
    } else {
      item.vulnerabilityText = 'There is no vulnerability';
      item.vulnerabilityCount = 0;
      item.vulnerabilities = {};
      item.highestSeverity = 'NONE';
    }

    if (!this.globalPackageList[item.coordinates]) {
      this.globalPackageList[item.coordinates] = item;
    } else {
      console.log(
        '****************** ' +
          item.coordinates +
          ' not found to add to globalPackageList ******************************',
      );
    }
  }
}
