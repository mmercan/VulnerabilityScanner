import request = require('request');
import { IPackage, IVulnerability, IProject, IProjectDic } from './models'
export default class QueryVulnerabilities {

    globalPackageList:any={};

    public async QueryAllPackages(projects: IProjectDic) {
        await this.getVulnerabilityreports(projects);

        for (let prj in projects) {
            for (let pcks in projects[prj].results) {

                if (this.globalPackageList[pcks]) {
                    projects[prj].results[pcks]=this.globalPackageList[pcks];
                }
            }
        }
    }


    public async getVulnerabilityreports(projects: IProjectDic) {
        let pageitem = 127;
        let allpages = [];
        let packagecoordinates = this.listAllPackages(projects);
        let totalpageNumber = Math.ceil(packagecoordinates.length / pageitem);

        for (let index = 0; index < totalpageNumber; index++) {
            let paged = this.paginate(packagecoordinates, pageitem, index)
            allpages.push(paged);

            try {
                await this.queryPackages(paged);
            } catch (error) {
                console.log(`catch: ${error}`)
            }
        }
        return allpages;
    }

    listAllPackages(projects: IProjectDic): any {
        let packagecoordinates: any = {};

        for (let prj in projects) {
            for (let pcks in projects[prj].results) {

                if (!packagecoordinates[pcks]) {
                    packagecoordinates[pcks] = {};
                }
            }
        }

        let packageList = [];
        for (let key in packagecoordinates) {
            packageList.push(key);
        }
        return packageList;
    }
    
    paginate(array: any[], page_size: number, page_number: number) {
        return array.slice(page_number * page_size, (page_number + 1) * page_size);
    }

    queryPackages(packagecoordinates: string[]) {
        return new Promise((resolve, reject) => {
            request.post("https://ossindex.sonatype.org/api/v3/component-report",
                { json: { coordinates: packagecoordinates } }
                , (error, res, body: IPackage[]) => {
                    if (error) {
                        console.error(error)
                        reject(error);
                        return
                    }
                    console.log(`statusCode: ${res.statusCode}`)
                    if (res.statusCode == 200) {
                        body.forEach(pck => {
                            this.extractpackagedata(pck);
                        });
                        resolve(body);
                    } else {
                        reject(body);
                    }
                });
        });
    }

    extractpackagedata(pck: IPackage) {
        let item: any = {};
        item.coordinates = pck.coordinates;
        item.highestCvssScore = 0;
        if (pck.vulnerabilities.length > 0) {
            item.vulnerabilityText = "There are  " + pck.vulnerabilities.length + " vulnerabilities";
            item.vulnerabilityCount = pck.vulnerabilities.length;
            item.vulnerabilities = pck.vulnerabilities;
        
            item.vulnerabilities.forEach((vulnerability: any) => {
                if (vulnerability.cvssScore) {

                    if(vulnerability.cvssScore > item.highestCvssScore)
                    {
                        item.highestCvssScore=vulnerability.cvssScore;
                    }
    
                    if (vulnerability.cvssScore >= 0.1 && vulnerability.cvssScore <= 3.9) {
                        vulnerability.severity = "LOW";
                        // if (failifseverityhigher == "LOW") {
                        //     shouldTaskFails = true;
                        //     vulnerability.TaskFailed = "Task Will Fail"
                        // }
                    }
    
                    if (vulnerability.cvssScore >= 4.0 && vulnerability.cvssScore <= 6.9) {
                        vulnerability.severity = "MEDIUM";
                        // severityForegroundColor = ConsoleColor.Yellow;
                        // if (failifseverityhigher == "LOW" || failifseverityhigher == "MEDIUM") {
                        //     shouldTaskFails = true;
                        //     vulnerability.TaskFailed = "Task Will Fail"
                        // }
                    }
    
                    if (vulnerability.cvssScore >= 7.0 && vulnerability.cvssScore <= 8.9) {
                        vulnerability.severity = "HIGH";
                        // severityForegroundColor = ConsoleColor.Red;
                        // if (failifseverityhigher == "LOW" || failifseverityhigher == "MEDIUM" ||
                        //     failifseverityhigher == "HIGH") {
                        //     shouldTaskFails = true;
                        //     vulnerability.TaskFailed = "Task Will Fail"
                        // }
                    }
    
                    if (vulnerability.cvssScore >= 9.0) {
                        vulnerability.severity = "CRITICAL";
                        // severityForegroundColor = ConsoleColor.Red;
                        // if (failifseverityhigher == "LOW" || failifseverityhigher == "MEDIUM" ||
                        //     failifseverityhigher == "HIGH" || failifseverityhigher == "CRITICAL") {
                        //     shouldTaskFails = true;
                        //     vulnerability.TaskFailed = "Task Will Fail"
                        // }
                    }
                }
            });

            if(item.highestCvssScore===0){
                item.highestSeverity = "NONE";
            }
            if(item.highestCvssScore >= 0.1 && item.highestCvssScore <= 3.9) {
                item.highestSeverity = "LOW";
            } else if (item.highestCvssScore >= 4.0 && item.highestCvssScore <= 6.9) {
                item.highestSeverity = "MEDIUM";
            } else if (item.highestCvssScore >= 7.0 && item.highestCvssScore <= 8.9) {
                item.highestSeverity = "HIGH";
            } else  if (item.highestCvssScore >= 9.0) {
                item.highestSeverity = "CRITICAL";
            }

    
        } else {
            item.vulnerabilityText = "There is no vulnerability";
            item.vulnerabilityCount = 0;
            item.vulnerabilities = {};
            item.highestSeverity = "NONE";
        }

        if (!this.globalPackageList[item.coordinates]) {
             this.globalPackageList[item.coordinates] = item;
        } else {
             console.log("****************** " + item.coordinates + " not found to add to globalPackageList ******************************")
         }

    }

}












